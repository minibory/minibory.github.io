[ { "title": "99클럽 코테 스터디 19일차 TIL + 구명보트", "url": "/posts/middler_18/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-08-09 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 문제 풀이import java.util.Arrays;class Solution { public int solution(int[] people, int limit) { Arrays.sort(people); int min = 0; int boats = 0; for(int max = people.length - 1; min &lt;= max; max--) { if (people[min] + people[max] &lt;= limit) { min++; } boats++; } return boats; }}마치고" }, { "title": "99클럽 코테 스터디 18일차 TIL + 단지번호붙이기", "url": "/posts/middler_17/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 백준, java", "date": "2024-08-08 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java문제 설명&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.예제 입력170110100011010111101010000111010000001111100111000예제 출력13789문제 풀이import java.util.*;import java.io.*;public class Main { static int[][] danji; static boolean[][] visited; static int[] dx = {0,0,-1,1}; static int[] dy = {-1,1,0,0}; static List&lt;Integer&gt; result; static int cnt, N; public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); result = new LinkedList&lt;&gt;(); N = Integer.parseInt(br.readLine()); danji = new int[N][N]; visited = new boolean[N][N]; cnt = 1; for(int i=0;i&lt;N;i++) { String str = br.readLine(); for(int j = 0; j &lt; N; j++) { danji[i][j] = str.charAt(j) - '0'; } } for(int x = 0; x &lt; N; x++) { for(int y = 0; y &lt; N; y++) { if(danji[x][y] == 1 &amp;&amp; !visited[x][y]) { dfs(x, y); result.add(cnt); cnt = 1; } } } Collections.sort(result); bw.write(result.size() + \"\\n\"); for(int r : result) bw.write(r + \"\\n\"); bw.flush(); bw.close(); } public static void dfs(int x, int y) { visited[x][y] = true; for(int i = 0; i &lt; 4; i++) { int nx = dx[i] + x; int ny = dy[i] + y; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; N &amp;&amp; !visited[nx][ny] &amp;&amp; danji[nx][ny] == 1) { cnt++; dfs(nx, ny); } } }}마치고" }, { "title": "99클럽 코테 스터디 17일차 TIL + 촌수 계산", "url": "/posts/middler_16/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 백준, java", "date": "2024-08-07 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java문제 설명우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.입력사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.각 사람의 부모는 최대 한 명만 주어진다.출력입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.예제 입력197 371 21 32 72 82 94 54 6예제 출력13예제 입력298 671 21 32 72 82 94 54 6예제 출력2-1문제 풀이import java.util.*;import java.io.*;public class Main { static int n, m, start, end; static int[][] graph; static int[] dist; public static void dfs(int index){ if(index == end) return; for(int i = 1; i &lt;= n; i++){ if(graph[index][i] == 1 &amp;&amp; dist[i] == 0){ dist[i] = dist[index] + 1; dfs(i); } } } public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); graph = new int[n + 1][n + 1]; dist = new int[n + 1]; StringTokenizer st = new StringTokenizer(br.readLine()); start = Integer.parseInt(st.nextToken()); end = Integer.parseInt(st.nextToken()); m = Integer.parseInt(br.readLine()); for(int i = 0; i &lt; m; i++){ st = new StringTokenizer(br.readLine()); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); graph[x][y] = graph[y][x] = 1; } dfs(start); System.out.println(dist[end] == 0 ? -1 : dist[end]); }}마치고dfs 알고리즘 카테고리여서 열심히 봤는데, 도통 모르겠어서 인터넷 검색을 해서 풀었다." }, { "title": "99클럽 코테 스터디 16일차 TIL + 모음사전", "url": "/posts/middler_15/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-08-06 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명사전에 알파벳 모음 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 “A”이고, 그다음은 “AA”이며, 마지막 단어는 “UUUUU”입니다.단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.제한사항 word의 길이는 1 이상 5 이하입니다. word는 알파벳 대문자 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’로만 이루어져 있습니다.입출력 예 word result “AAAAE” 6 “AAAE” 10 “I” 1563 “EIO” 1189 문제 풀이import java.util.*;class Solution { List&lt;String&gt; list = new ArrayList&lt;&gt;(); public int solution(String word) { dfs(\"\", 0); return list.indexOf(word); } private void dfs(String str, int len) { if(len &gt; 5) return; list.add(str); for(int i = 0; i &lt; 5; i++) { dfs(str + \"AEIOU\".charAt(i), len + 1); } }}마치고오늘은 감이 안잡혀서 찾아보다가 dfs알고리즘을 알게 되었다.주말에 추가적으로 더 학습해야겠다." }, { "title": "99클럽 코테 스터디 15일차 TIL + Prefix and Suffix Search", "url": "/posts/middler_14/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, leetcode, java", "date": "2024-08-05 16:00:00 +0900", "snippet": "언어Java문제 설명Design a special dictionary that searches the words in it by a prefix and a suffix.Implement the WordFilter class: WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.제한사항 1 &lt;= words.length &lt;= 104 1 &lt;= words[i].length &lt;= 7 1 &lt;= pref.length, suff.length &lt;= 7 words[i], pref and suff consist of lowercase English letters only. At most 104 calls will be made to the function f.예제Input[\"WordFilter\", \"f\"][[[\"apple\"]], [\"a\", \"e\"]]Output[null, 0]ExplanationWordFilter wordFilter = new WordFilter([\"apple\"]);wordFilter.f(\"a\", \"e\"); // return 0, because the word at index 0 has prefix = \"a\" and suffix = \"e\".문제 풀이import java.util.*;class WordFilter { private Map&lt;String, Integer&gt; map; public WordFilter(String[] words) { map = new HashMap&lt;&gt;(); for(int index = 0; index &lt; words.length; index++) { String word = words[index]; int length = word.length(); for(int i = 0; i &lt;= length; i++) { for(int j = 0; j &lt;= length; j++) { String key = word.substring(0, i) + \"#\" + word.substring(length - j); map.put(key, index); } } } } public int f(String pref, String suff) { String key = pref + \"#\" + suff; return map.getOrDefault(key, -1); }}마치고처음 본 코테 플랫폼에 정신 못차렸다." }, { "title": "99클럽 코테 스터디 14일차 TIL + 숫자 카드2", "url": "/posts/middler_13/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 백준, java", "date": "2024-08-04 16:00:00 +0900", "snippet": "언어Java문제 설명숫자 카드는 정수 하나가 적혀져 있는 카드이다.상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다.둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다.넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.출력첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.예제 입력106 3 2 10 10 10 -10 -10 7 3810 9 -5 2 3 4 5 -10예제 출력3 0 0 1 2 0 0 2문제 풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;class Solution { public int startBinarySearch(int[] arr, int n){ int left = 0; int right = arr.length; while(left &lt; right) { int mid = (left + right) / 2; if(arr[mid] &gt;= n) right = mid; else left = mid + 1; } return left; } public int endBinarySearch(int[] arr, int n){ int left = 0; int right = arr.length; while(left &lt; right) { int mid = (left + right) / 2; if(arr[mid] &gt; n) right = mid; else left = mid + 1; } return left; }}public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int N = Integer.parseInt(br.readLine()); int[] arr = new int[N]; StringTokenizer st = new StringTokenizer(br.readLine()); for(int i = 0; i &lt; N; i++) { arr[i] = Integer.parseInt(st.nextToken()); } Arrays.sort(arr); int M = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine()); Solution s = new Solution(); for(int i = 0; i &lt; M; i++) { int num = Integer.parseInt(st.nextToken()); sb.append(s.endBinarySearch(arr, num) - s.startBinarySearch(arr, num)).append(\" \"); } System.out.println(sb); }}마치고-" }, { "title": "99클럽 코테 스터디 13일차 TIL + 숫자 카드", "url": "/posts/middler_12/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 백준, java", "date": "2024-08-03 16:00:00 +0900", "snippet": "언어Java문제 설명숫자 카드는 정수 하나가 적혀져 있는 카드이다.상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.입력첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다.둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다.넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.출력첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.예제 입력56 3 2 10 -10810 9 -5 2 3 4 5 -10예제 출력1 0 0 1 1 0 0 1문제 풀이import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;class Solution { public int binarySearch(int[] arr, int n){ int left = 0; int right = arr.length - 1; while(left &lt;= right) { int mid = (left + right) / 2; if(arr[mid] &lt; n) left = mid + 1; else if(arr[mid] &gt; n) right = mid - 1; else return 1; } return 0; }}public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); int N = Integer.parseInt(br.readLine()); int[] arr = new int[N]; StringTokenizer st = new StringTokenizer(br.readLine()); for(int i = 0; i &lt; N; i++) { arr[i] = Integer.parseInt(st.nextToken()); } Arrays.sort(arr); int M = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine()); Solution s = new Solution(); for(int i = 0; i &lt; M; i++) { int num = Integer.parseInt(st.nextToken()); sb.append(s.binarySearch(arr, num)).append(\" \"); } System.out.println(sb); }}마치고백준은 처음인데 문제 제출 방식이 프로그래머스랑 달라서 혼돈이 왔었다." }, { "title": "99클럽 코테 스터디 12일차 TIL + H-Index", "url": "/posts/middler_11/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-08-02 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다.입출력 예 citations result [3, 0, 6, 1, 5] 3 입출력 예 설명이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.문제 풀이import java.util.Arrays;class Solution { public int solution(int[] citations) { Arrays.sort(citations); for (int i = 0; i &lt; citations.length; i++) { int h = citations.length - i; if (citations[i] &gt;= h) { return h; } } return 0; }}마치고머리아팠다." }, { "title": "99클럽 코테 스터디 11일차 TIL + 카드 뭉치", "url": "/posts/middler_10/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-08-01 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명코니는 영어 단어가 적힌 카드 뭉치 두 개를 선물로 받았습니다. 코니는 다음과 같은 규칙으로 카드에 적힌 단어들을 사용해 원하는 순서의 단어 배열을 만들 수 있는지 알고 싶습니다. 원하는 카드 뭉치에서 카드를 순서대로 한 장씩 사용합니다. 한 번 사용한 카드는 다시 사용할 수 없습니다. 카드를 사용하지 않고 다음 카드로 넘어갈 수 없습니다. 기존에 주어진 카드 뭉치의 단어 순서는 바꿀 수 없습니다.예를 들어 첫 번째 카드 뭉치에 순서대로 [“i”, “drink”, “water”], 두 번째 카드 뭉치에 순서대로 [“want”, “to”]가 적혀있을때 [“i”, “want”, “to”, “drink”, “water”] 순서의 단어 배열을 만들려고 한다면 첫 번째 카드 뭉치에서 “i”를 사용한 후 두 번째 카드 뭉치에서 “want”와 “to”를 사용하고 첫 번째카드뭉치에 “drink”와 “water”를 차례대로 사용하면 원하는 순서의 단어 배열을 만들 수 있습니다.문자열로 이루어진 배열 cards1, cards2와 원하는 단어 배열 goal이 매개변수로 주어질 때, cards1과 cards2에 적힌 단어들로 goal를 만들 있다면 “Yes”를, 만들 수 없다면 “No”를return하는 solution 함수를 완성해주세요.제한사항 1 ≤ cards1의 길이, cards2의 길이 ≤ 10 1 ≤ cards1[i]의 길이, cards2[i]의 길이 ≤ 10 cards1과 cards2에는 서로 다른 단어만 존재합니다. 2 ≤ goal의 길이 ≤ cards1의 길이 + cards2의 길이 1 ≤ goal[i]의 길이 ≤ 10 goal의 원소는 cards1과 cards2의 원소들로만 이루어져 있습니다. cards1, cards2, goal의 문자열들은 모두 알파벳 소문자로만 이루어져 있습니다.입출력 예 cards1 cards2 goal result [“i”, “drink”, “water”] [“want”, “to”] [“i”, “want”, “to”, “drink”, “water”] “Yes” [“i”, “water”, “drink”] [“want”, “to”] [“i”, “want”, “to”, “drink”, “water”] “No” 입출력 예 설명입출력 예 #1본문과 같습니다.입출력 예 #2cards1에서 “i”를 사용하고 cards2에서 “want”와 “to”를 사용하여 “i want to”까지는 만들 수 있지만 “water”가 “drink”보다 먼저 사용되어야 하기 때문에 해당 문장을 완성시킬 수없습니다. 따라서 “No”를 반환합니다.문제 풀이class Solution { public String solution(String[] cards1, String[] cards2, String[] goal) { int index1 = 0; int index2 = 0; for (String g : goal) { if (index1 &lt; cards1.length &amp;&amp; g.equals(cards1[index1])) { index1++; } else if (index2 &lt; cards2.length &amp;&amp; g.equals(cards2[index2])) { index2++; } else { return \"No\"; } } return \"Yes\"; }}마치고오늘은 좀 쉽다." }, { "title": "99클럽 코테 스터디 10일차 TIL + 이중우선순위큐", "url": "/posts/middler_9/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-31 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.3문제 설명이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다. 명령어 수신 탑(높이) I 숫자 큐에 주어진 숫자를 삽입합니다. D 1 큐에서 최댓값을 삭제합니다. D -1 큐에서 최솟값을 삭제합니다. 이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를구현해주세요.제한사항 operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다. operations의 원소는 큐가 수행할 연산을 나타냅니다. 원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다. 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다.입출력 예 operations return [“I 16”, “I -5643”, “D -1”, “D 1”, “D 1”, “I 123”, “D -1”] [0,0] [“I -45”, “I 653”, “D 1”, “I -642”, “I 45”, “I 97”, “D 1”, “D -1”, “I 333”] [333, -45] 입출력 예 설명입출력 예 #1 16과 -5643을 삽입합니다. 최솟값을 삭제합니다. -5643이 삭제되고 16이 남아있습니다. 최댓값을 삭제합니다. 16이 삭제되고 이중 우선순위 큐는 비어있습니다. 우선순위 큐가 비어있으므로 최댓값 삭제 연산이 무시됩니다. 123을 삽입합니다. 최솟값을 삭제합니다. 123이 삭제되고 이중 우선순위 큐는 비어있습니다.따라서 [0, 0]을 반환합니다.입출력 예 #2-45와 653을 삽입후 최댓값(653)을 삭제합니다. -45가 남아있습니다.-642, 45, 97을 삽입 후 최댓값(97), 최솟값(-642)을 삭제합니다. -45와 45가 남아있습니다. 333을 삽입합니다.이중 우선순위 큐에 -45, 45, 333이 남아있으므로, [333, -45]를 반환합니다.문제 풀이import java.util.Collections;import java.util.PriorityQueue;class Solution { public int[] solution(String[] operations) { PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); for(String operation : operations) { String[] arr = operation.split(\" \"); int num = Integer.parseInt(arr[1]); if(\"I\".equals(arr[0])) { minHeap.offer(num); maxHeap.offer(num); } else if(\"D\".equals(arr[0])) { if(!minHeap.isEmpty() &amp;&amp; num == 1) { minHeap.remove(maxHeap.poll()); } else if(!maxHeap.isEmpty() &amp;&amp; num == -1) { maxHeap.remove(minHeap.poll()); } } } if(minHeap.isEmpty() &amp;&amp; maxHeap.isEmpty()) { return new int[]{0, 0}; } else { return new int[]{maxHeap.peek(), minHeap.peek()}; } }}마치고어제 힙에 대해 공부해놔서인지 오늘 문제가 Lv.3인데도 불가하고 할만했다." }, { "title": "99클럽 코테 스터디 9일차 TIL + 더 맵게", "url": "/posts/middler_8/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-30 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로섞어 새로운 음식을 만듭니다.섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution함수를 작성해주세요.제한사항 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.입출력 예 scoville k return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 설명 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13가진 음식의 스코빌 지수 = [13, 9, 10, 12] 문제 풀이import java.util.PriorityQueue;class Solution { public int solution(int[] scoville, int K) { PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); for (int s : scoville) { minHeap.add(s); } int answer = 0; while (minHeap.size() &gt; 1 &amp;&amp; minHeap.peek() &lt; K) { int leastSpicy = minHeap.poll(); int secondLeastSpicy = minHeap.poll(); int mixScoville = leastSpicy + (secondLeastSpicy * 2); minHeap.add(mixScoville); answer++; } if (minHeap.peek() &lt; K) { return -1; } return answer; }}마치고문제의 카테고리가 힙인데, 어떤 개념인지 잘 몰라서 문제를 풀기 전에 먼저 학습을 하고자 하다가 자바의 PriorityQueue에 대해 알게 되었다.원래는 Arrays를 import하기 싫어서 버블 정렬로 scoville 배열을 정렬하고 시작하려 했는데, PriorityQueue는 최소 힙의 구조로 정렬해 줘서 딱히 필요 없었다.힙과 큐의 개념에 대해서 좀 더 공부를 해봐야 겠다." }, { "title": "99클럽 코테 스터디 8일차 TIL + 기능개발", "url": "/posts/middler_7/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-29 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록solution 함수를 완성하세요.제한사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 문제 풀이import java.util.*;class Solution { public int[] solution(int[] progresses, int[] speeds) { Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; progresses.length; i++) { int remainDay = 100 - progresses[i]; int currentDeploymentDay = remainDay / speeds[i]; currentDeploymentDay += remainDay % speeds[i] &gt; 0 ? 1 : 0; queue.add(currentDeploymentDay); } while (!queue.isEmpty()) { int currentDeploymentDay = queue.poll(); int count = 1; while (!queue.isEmpty() &amp;&amp; queue.peek() &lt;= currentDeploymentDay) { count++; queue.poll(); } result.add(count); } int[] answer = new int[result.size()]; for (int i = 0; i &lt; result.size(); i++) { answer[i] = result.get(i); } return answer; }}마치고어떻게 풀어야하나 고민하고 있었는데, 문제의 카테고리가 스택/큐 였다.스택이랑 큐를 둘 다 사용할 것 같진 않아서 하나씩 생각을 해봤는데, 큐를 쓰는게 맞아보여서 큐로 시도했는데 성공했다." }, { "title": "99클럽 코테 스터디 7일차 TIL + 하노이의 탑", "url": "/posts/middler_6/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-28 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. 한 번에 하나의 원판만 옮길 수 있습니다. 큰 원판이 작은 원판 위에 있어서는 안됩니다.하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다. 1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮기려고 합니다.1번 기둥에 있는 원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 3번 원판으로 최소로 옮기는 방법을 return하는 solution를 완성해주세요.제한사항 n은 15이하의 자연수 입니다.입출력 예 n result 2 [ [1,2], [1,3], [2,3] ] 문제 풀이class Solution { private int move(int n, int from, int aux, int to, int[][] arr, int index) { if (n == 1) { arr[index] = new int[]{from, to}; return index + 1; } index = move(n - 1, from, to, aux, arr, index); arr[index] = new int[]{from, to}; index++; index = move(n - 1, aux, from, to, arr, index); return index; } public int[][] solution(int n) { int moveCount = (int) Math.pow(2, n) - 1; int[][] arr = new int[moveCount][2]; move(n, 1, 2, 3, arr, 0); return arr; }}마치고오늘은 제한시간은 커녕 이해를 못해서 풀지를 못했다.결국 하노이 탑 알고리즘 및 문제 풀이를 검색했다.재귀 호출을 이용하는데, 복잡하고 어려워서 코드르 달달 외워야겠다." }, { "title": "99클럽 코테 스터디 6일차 TIL + 의상", "url": "/posts/middler_5/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-27 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명코니는 매일 다른 옷을 조합하여 입는것을 좋아합니다.예를 들어 코니가 가진 옷이 아래와 같고, 오늘 코니가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 코니는 각 종류별로 최대 1가지 의상만 착용할 수 있습니다. 예를 들어 위 예시의 경우 동그란 안경과 검정 선글라스를 동시에 착용할 수는 없습니다. 착용한 의상의 일부가 겹치더라도, 다른 의상이 겹치지 않거나, 혹은 의상을 추가로 더 착용한 경우에는 서로 다른 방법으로 옷을 착용한 것으로 계산합니다. 코니는 하루에 최소 한 개의 의상은 입습니다.코니가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 코니가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.입출력 예 clothes return [[“yellow_hat”, “headgear”], [“blue_sunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crow_mask”, “face”], [“blue_sunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. yellow_hat blue_sunglasses green_turban yellow_hat + blue_sunglasses green_turban + blue_sunglasses예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. crow_mask blue_sunglasses smoky_makeup문제 풀이import java.util.HashMap;class Solution { public int solution(String[][] clothes) { HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for(String[] cloth: clothes) { map.put(cloth[1], map.getOrDefault(cloth[1], 0) + 1); } int sum = 1; for(int count : map.values()) { sum *= (count + 1); } return sum - 1; }}마치고의상의 종류가 key가 아닌 value쪽에 있어서 헷갈렸고, 마지막에 아무것도 입지 않은 경우를 생각하여 -1 하는 것을 늦게 생각했다." }, { "title": "99클럽 코테 스터디 5일차 TIL + 전화번호 목록", "url": "/posts/middler_4/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-26 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.제한사항 phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다. 입출력 예 phone_book return [“119”, “97674223”, “1195524421”] false [“123”,”456”,”789”] true [“12”,”123”,”1235”,”567”,”88”] false 문제 풀이풀이 1import java.util.Arrays;class Solution { public boolean solution(String[] phoneBook) { Arrays.sort(phoneBook); String temp = phoneBook[0]; for(int i = 1; i &lt; phoneBook.length; i++) { if(phoneBook[i].startsWith(temp)) { return false; } else { temp = phoneBook[i]; } } return true; }}정답이긴 하나, 문제의 카테고리가 해시여서 해시를 사용하여 풀이 2를 진행했다.풀이 2import java.util.HashMap;class Solution { public boolean solution(String[] phoneBook) { HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); for(String number : phoneBook) { map.put(number, number); } for(String number : phoneBook) { for(int i = 1; i &lt; number.length(); i++) { if(map.containsKey(number.substring(0, i))) { return false; } } } return true; }}뭔가 더 효율적인 방법이 있을 것 같은데, 생각이 나지 않는다.마치고풀이를 마치고 더 효율적인 방법에 대해 검색해보다가 트라이(Trie) 라는 자료구조를 찾았다.해시문제를 조금 더 풀어보고, 나중에는 이 자료구조를 이용하여 풀어봐야겠다." }, { "title": "99클럽 코테 스터디 4일차 TIL + JadenCase 문자열 만들기", "url": "/posts/middler_3/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-25 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다.단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고)문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.제한사항 s는 길이 1 이상 200 이하인 문자열입니다. s는 알파벳과 숫자, 공백문자(“ “)로 이루어져 있습니다. 숫자는 단어의 첫 문자로만 나옵니다. 숫자로만 이루어진 단어는 없습니다. 공백문자가 연속해서 나올 수 있습니다. 입출력 예 s return “3people unFollowed me” “3people Unfollowed Me” “for the last week” “For The Last Week” 문제 풀이class Solution { public String solution(String s) { s = s.toLowerCase(); StringBuilder sb = new StringBuilder(); sb.append(Character.toUpperCase(s.charAt(0))); for(int i = 1; i &lt; s.length(); i++){ if(s.charAt(i) == ' ') sb.append(\" \"); else if(s.charAt(i - 1) == ' ') sb.append(Character.toUpperCase(s.charAt(i))); else sb.append(s.charAt(i)); } return sb.toString(); }}마치고문장의 첫 글자를 먼저 대문자로 바꿔주기때문에 for문의 i를 1로 작성했다." }, { "title": "99클럽 코테 스터디 3일차 TIL + 문자열 내 마음대로 정렬하기", "url": "/posts/middler_2/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-25 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다.예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다.제한사항 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.입출력 예 strings n return [“sun”, “bed”, “car”] 1 [“car”, “bed”, “sun”] [“abce”, “abcd”, “cdx”] 2 [“abcd”, “abce”, “cdx”] 문제 풀이import java.util.Arrays;class Solution { public String[] sort(String[] strings, int n) { Arrays.sort(strings, (s1, s2) -&gt; { if (s1.charAt(n) == s2.charAt(n)) { return s1.compareTo(s2); } else { return Character.compare(s1.charAt(n), s2.charAt(n)); } }); return strings; } public String[] solution(String[] strings, int n) { return sort(strings, n); }}마치고Character.compare(s1.charAt(n), s2.charAt(n));부분을s1.charAt(n) - s2.charAt(n);로 작성해도 정상작동하나 속도가 아주 미세하게 느리다고 한다." }, { "title": "99클럽 코테 스터디 2일차 TIL + x만큼 간격이 있는 n개의 숫자", "url": "/posts/middler_1/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-25 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다.다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.제한 조건 x는 -10000000 이상, 10000000 이하인 정수입니다. n은 1000 이하인 자연수입니다.입출력 예 x n answer 2 5 [2,4,6,8,10] 4 3 [4,8,12] -4 2 [-4, -8] 문제 풀이class Solution { public long[] solution(int x, int n) { long[] answer = new long[n]; long sum = x; for(int i = 0; i &lt; n; i++) { answer[i] = sum; sum += x; } return answer; }}마치고문제에 return타입이 long[]이여서 long으로 진행했다." }, { "title": "99클럽 코테 스터디 1일차 TIL + n^2 배열 자르기", "url": "/posts/middler_0/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-25 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.2문제 설명정수 n, left, right가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다. n행 n열 크기의 비어있는 2차원 배열을 만듭니다. i = 1, 2, 3, …, n에 대해서, 다음 과정을 반복합니다. 1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다. 1행, 2행, …, n행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다. 새로운 1차원 배열을 arr이라 할 때, arr[left], arr[left+1], …, arr[right]만 남기고 나머지는 지웁니다.정수 n, left, right가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요.제한사항 1 ≤ n ≤ 10⁷ 0 ≤ left ≤ right &lt; n² right - left &lt; 10⁵입출력 예 n left right result 3 2 5 [3,2,2,3] 4 7 14 [4,3,3,3,4,4,4,4] 문제 풀이class Solution { public int[] getArray(int n, long left, long right) { int[] array = new int[(int)(right - left + 1)]; for(long i = left; i &lt;= right; i++) { int num1 = (int)(i / n + 1); int num2 = (int)(i % n + 1); array[(int)(i - left)] = num1 &gt; num2 ? num1 : num2; } return array; } public int[] solution(int n, long left, long right) { return getArray(n, left, right); }}마치고문제에 주어진 매개변수가 long 타입이라 int로 변환해줬는데, 코드가 썩 맘에 들진 않는다." }, { "title": "99클럽 코테 스터디 3일차 TIL + 문자열 내 p와 y의 개수", "url": "/posts/beginner_2/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-24 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요.‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다.제한사항 문자열 s의 길이 : 50 이하의 자연수 문자열 s는 알파벳으로만 이루어져 있습니다.입출력 예 n return “pPoooyY” true “Pyy” false 입출력 예 설명입출력 예 #1‘p’의 개수 2개, ‘y’의 개수 2개로 같으므로 true를 return 합니다.입출력 예 #2‘p’의 개수 1개, ‘y’의 개수 2개로 다르므로 false를 return 합니다.문제 풀이class Solution { boolean solution(String s) { boolean answer = true; int pCnt = 0, yCnt = 0; for(int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if('p' == c || 'P' == c) pCnt++; if('y' == c || 'Y' == c) yCnt++; } return pCnt == yCnt; }}마치고더 좋은 방법이 있을 것 같다." }, { "title": "99클럽 코테 스터디 2일차 TIL + 평균 구하기", "url": "/posts/beginner_1/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-23 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.제한사항 arr은 길이 1 이상, 100 이하인 배열입니다. arr의 원소는 -10,000 이상 10,000 이하인 정수입니다.입출력 예 n return [1,2,3,4] 2.5 [5,5] 5 문제 풀이class Solution { public double solution(int[] arr) { double sum = 0; for(int i = 0; i &lt; arr.length; i++) { sum += arr[i]; } return sum / arr.length; }}마치고가능한 라이브러리를 사용하지 않도록 노력하려고 한다." }, { "title": "99클럽 코테 스터디 1일차 TIL + 자연수 뒤집어 배열로 만들기", "url": "/posts/beginner_0/", "categories": "TIL", "tags": "99클럽, 코딩테스트 준비, 개발자 취업, 항해99, TIL, 프로그래머스, java", "date": "2024-07-22 16:00:00 +0900", "snippet": "언어 / 문제 난이도Java / Lv.1문제 설명자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요.예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다.제한사항 n은 10,000,000,000이하인 자연수입니다.입출력 예 n return 12345 [5,4,3,2,1] 문제 풀이class Solution { public int[] solution(long n) { int[] answer = new int[String.valueOf(n).length()]; int index = 0; while(n &gt; 0) { answer[index++] = (int) (n % 10); n = n / 10; } return answer; }}마치고우려와 달리 첫날을 무사히 마무리할 수 있어서 안심이다." }, { "title": "[Error] Unboxing of may produce 'NullPointerException'", "url": "/posts/exception_0/", "categories": "Exception, Error", "tags": "Exception, error, NullPointerException, Wrapper Class, Primitive Type", "date": "2022-08-25 00:50:00 +0900", "snippet": "현상public boolean isExists(String key) { return redisTemplate.hasKey(key);}위 코드에서 Unboxing of may produce 'NullPointerException' 이라는 경고 문구 확인원인return redisTemplate.hasKey(key);위 리턴 타입은 Wrapper Class인데,public boolean isExists(String key) {위 함수의 리턴 타입이 Primitive Type이라 null에 대한 체크가 불가하여 NullPointerException 경고해결public Boolean isExists(String key) { return redisTemplate.hasKey(key);}함수의 리턴 타입을 Boolean(Wrapper Class)으로 변경" }, { "title": "[OS] RAM과 ROM의 차이", "url": "/posts/os_2/", "categories": "Operating System", "tags": "OS, 운영체제, Operating System, RAM, ROM", "date": "2022-08-23 00:50:00 +0900", "snippet": "💡 RAM(Random Access Memory) 단기 데이터 스토리지로, 정보에 빠르게 접근할 수 있도록 데이터를 임시 저장한다. 휘발성 메모리이며, 컴퓨터를 재시작하거나 종료할 경우 데이터들은 삭제된다.💡 ROM(Read Only Memory) 컴퓨터를 구동하기 위한 기본적인 정보가 저장되어있다. 비휘발성 메모리이며, 정보를 영구적으로 저장한다.📌 RAM &amp; ROM 비교 RAM ROM 휘발성 메모리 비휘발성 메모리 읽기/쓰기 읽기 사용자가 변경 가능 사용자가 변경 불가 전원이 차단되면 데이터 삭제 전원이 차단되어도 데이터 유지 속도가 빠름 속도가 느림 " }, { "title": "[OS] 캐시(페이지) 교체 알고리즘 종류", "url": "/posts/os_1/", "categories": "Operating System", "tags": "OS, 운영체제, Operating System", "date": "2022-08-23 00:50:00 +0900", "snippet": "💡 캐시(Cache)데이터, 값을 미리 복사해 놓는 임시 저장소이며, 접근 시간을 대폭 줄여 컴퓨터 시스템의 성능을 향상시켜준다.캐시의 종류에 따른 성능은 레지스터 &gt; 캐시 메모리 &gt; 메인 메모리(RAM) &gt; 스토리지(디스크) 순이다. [자세한 내용]——캐시 교체 알고리즘의 종류1. FIFO(First In First Out) 가장 오래된 캐시 교체 자주 사용되는 캐시가 교체될 수 있다는 단점이 있다. Belady`s Anomaly 현상 발생 가능성이 있다. [자세한내용]2. OPT(Optimal) 앞으로 가장 오랜 시간 사용되지 않을 캐시 교체 가장 이상적인 알고리즘 미래를 알아야 한다는 조건때문에 실현 불가능 비교 연구 목적으로 사용 3. LRU(Least Recently Used) 가장 오랜 시간 사용되지 않은 캐시 교체 오랜 시간 사용되지 않은 캐시는 앞으로도 사용되지 않을 확률이 높다고 판단 가장 많이 사용되는 알고리즘4. LFU(Least Frequently Used) 참조 횟수가 가장 적은 캐시 교체 교체 대상인 캐시가 여러 개 일 경우, LRU 알고리즘 방식으로 교체 가장 최근에 참조된 캐시가 교체될 수 있다는 단점이 있다.5. MFU(Most Frequently Used) 가장 많이 참조되는 캐시 교체 자주 참조되는 캐시는 앞으로 사용되지 않을 확률이 높다고 판단 6. SCR(Second Chance Replacement) 가장 오래된 캐시 교체 자주 사용되는 캐시의 교체를 방지 FIFO 알고리즘의 단점 보완 참조 비트를 검사하여 1일 경우 0으로 변경 후 마지막으로 삽입7. NUR(Not Used Recently, NRU) 가장 오랜 시간 사용되지 않은 캐시 교체 오랜 시간 사용되지 않은 캐시는 앞으로도 사용되지 않을 확률이 높다고 판단 LRU 알고리즘에서 나타나는 overhead 감소 최근 사용 여부를 판단하기 위해 각 캐시마다 2개의 비트 사용 참조 비트(Reference Bit) : 캐시가 참조되었을 때 1, 참조되지 않았을 때 0 변형 비트(Modified Bit, Dirty Bit) : 캐시가 변경되었을 때 1, 변경되지 않았을 때 1 캐시 교체 우선순위 1 - 참조 비트 0, 변형 비트 0 2 - 참조 비트 0, 변형 비트 1 3 - 참조 비트 1, 변형 비트 0 4 - 참조 비트 1, 변형 비트 1 8. Random 임의 캐시 교체 overhead가 적다.※ 오버헤드(overhead)- 시스템을 관리하기 위한 처리 시간이나 메모리 용량" }, { "title": "[Network] ARQ(Automatic Repeat Request) 종류", "url": "/posts/network_1/", "categories": "Network", "tags": "network, 네트워크, ARQ", "date": "2022-08-22 00:50:00 +0900", "snippet": "💡 ARQ Automatic Repeat Request에러 발생 혹은 손상 시, 수신 측은 송신 측에 알리고, 송신 측은 재전송을 요청하여 에러를 제어하는 방식ARQ 종류1. Stop and Wait (정지 대기 방식) 하나의 블록을 송신 후, 수신측으로부터 정상 응답(ACK) 신호를 받으면 데이터를 전송하는 방식 정상 응답(ACK) 신호가 오지 않으면 에러가 발생한 것으로 판단 전송 효율이 낮다는 단점이 있다.2. Go-Back-N ARQ / Continuous ARQ (연속적 ARQ) 효율이 낮은 Stop and Wait (정지 대기 방식)의 단점(overhead 발생)을 보완 여러 개의 블록을 송신 후, 수신측으로부터 정상 응답(ACK) 신호를 받으면 데이터를 전송하는 방식 비정상 응답(NAK)을 수신할 때까지 계속해서 데이터 전송 비정상 응답(NAK)을 수신하거나 프레임이 손상/분실되면 에러가 발생한 블록부터 모두 재전송3. Selective Repeat ARQ (선택적 ARQ) 에러가 발생한 블록부터 모두 재전송해야하는 연속적 ARQ의 단점을 보완 연속적 ARQ와 비슷하지만, 비정상 응답(NAK)을 수신하면 에러가 발생한 블록만 재전송 수신 측의 구조가 복잡하고, 프레임(데이터) 재배열을 위한 별도의 버퍼가 필요4. Adaptive ARQ (적응적 ARQ) 재전송 요청 비율(오류 발생률)에 따라 블록의 길이를 동적으로 변경하여 전송하는 방식 (요청 비율이 클수록 블록의 길이를 작게) 전송 효율은 높지만, 제어 회로가 복잡하고 채널의 대기시간이 발생" }, { "title": "[Network] URI와 URL의 차이(URI & URL)", "url": "/posts/network_0/", "categories": "Network", "tags": "network, 네트워크, URL, URI", "date": "2022-08-10 00:50:00 +0900", "snippet": "💡 URI(Uniform Resource Identifier) 자원을 나타내는 고유 식별자이다. URI는 다음과 같은 형태로 구성되어 있다.scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] [자세한 내용]——💡 URL(Uniform Resource Locator) URL은 URI의 하위 개념이며, 자원이 존재하는 위치를 나타내는 주소이다. URL는 다음과 같은 형태로 구성되어 있다.scheme:[//[user[:password]@]host[:port]][/path] [자세한 내용]——📃 예시⚠️ URI vs URL URL은 자원이 존재하는 위치까지만 나타내기 때문에 특정 자원의 정보가 파라미터에 따라 달라진다면 자원의 정보까지 접근하지 못한다.해당 자원에 접근하기 위해선 URI의 개념이 필요하다." }, { "title": "[OS] 데드락(DeadLock, 교착 상태)의 발생조건과 해결방법", "url": "/posts/os_0/", "categories": "Operating System", "tags": "OS, 운영체제, Operating System, DeadLock, 교착상태", "date": "2022-07-19 00:50:00 +0900", "snippet": "💡 데드락(DeadLock, 교착 상태)둘 이상의 프로세스가 서로 다른 프로세스의 자원이 끝나기를 무한히 기다리는 상황⚠️ 발생조건아래 4가지 조건이 모두 충족하면 데드락(DeadLock) 즉, 교착 상태가 일어난다.1. 상호 배제(Mutual exclusion) 자원을 동시에 사용할 수 없는 경우, 즉 자원을 한번에 한 프로세스만 사용할 수 있다. 2. 점유 대기(Hold and wait) 프로세스가 이미 자원을 보유한 상태에서 다른 프로세스에 할당된 자원을 추가로 요구하고 있다. 3. 선점 불가(No preemption) 프로세스에 이미 할당된 자원은 사용이 끝날 때까지 빼앗을 수 없다. 4. 순환 대기(Circular wait) 프로세스가 요구하는 자원이 순환 형태를 이루고 있다. 점유 대기와 선점 불가가 만족해야 성립된다.💊해결 방법1. 예방(Prevention) 상호 배제 자원을 공유 가능하도록 한다. 점유 대기 프로세스가 수행되기 전에 모든 자원을 할당하거나 점유되지 않은 자원만을 요구하도록 한다. 선점 불가 선점이 가능하도록 한다. 이미 자원이 할당된 프로세스가 다른 자원을 추가로 요구할때 할당된 자원을 반납하고, 요구한 자원을 기다리도록 한다. 순환 대기 자원에 고유 번호 및 순서를 부여한다. ※ 예방 방법은 시스템의 처리량과 효율성을 떨어트리는 단점이 있다.2. 회피(Avoidance) 교착 상태가 발생할 가능성이 있는 상태(순서가 부여되지 않은 상태)에서는 자원을 할당하지 않는다.3. 탐지(Detection) &amp; 회복(Recovery) 주기적으로 시스템에 교착 상태가 발생했는지 판단(탐지, Detection)하고, 만약 교착 상태가 탐지되었다면 해당 프로세스를 종료하거나 해당 자원을 선점하여 복구(회복, Recovery)한다." } ]
